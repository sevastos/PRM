'use strict';

var __ = require('lodash');
var async = require('async');
var debug = require('debug')('Camera');

var proc = require('./lib/proc');

/**
 * @param {String} name
 * @param {Object} port {type: (usb|serial), [bus: ..., dev: ...]}
 */
function Camera(name, port){
  if (typeof port === 'string') {
    port = Camera.portFromString(port);
  }
  this.name = name;
  this.port = port;

  if (port.type === 'usb') {
    this.portId = port.type + ':' + port.bus + ',' + port.dev;
  }
}

Camera.prototype.toString = function() {
  return '[' + this.name + ', Port:' + this.portId + ']';
};

Camera.portFromString = function(portStr) {
  portStr = portStr.split(':');
  return {
    type: portStr.shift(),
    bus: portStr[0].split(',')[0],
    dev: portStr[0].split(',')[1]
  };
};

/*****************/
/* Options chain */
/*****************/
/**
  One-time options.

  Will set provided options and
  revert to the original values
  after the next call (TODO)

 opts = [
  [key, value]
 ]

 */
Camera.prototype.optionsOnce = function(opts, next) {
  var _this = this;
  var oldSettings = [];

  if (!__.isArray(opts[0])) {
    opts = [opts];
  }

  var cmd = '';

  opts.forEach(function(option){
    cmd += ' --get-config ' + option[0] +
           ' --set-config ' + option[0] +
              '=' + (isNaN(option[1])?'"'+option[1]+'"':option[1]);
  });

  debug('optionsOnce', 'Gettings old vals & setting temp vals:', opts);
  debug('optionsOnce', 'cmd:', cmd);
  proc.gmd(cmd.trim(), function(res){
    var match, r = /^Current:(.*)$/gm;
    _this.oldSettings = [];
    while (match = r.exec(res), match !== null) {
      debug('optionsOnce', 'Found:', opts[_this.oldSettings.length][0], ', Val:', match[1]);
      _this.oldSettings.push([
        opts[_this.oldSettings.length][0], // Config Key
        match[1].trim()                   // Config value
      ]);
    }
    debug('optionsOnce', 'Done getting & setting options');
    next(_this);
  });
  return this;

  // OLD
  async.eachSeries(opts, function(option, doneSettingOpt){
    debug('optionsOnce', 'Gettings current val for config:', option[0]);
    proc.gmd('--get-config ' + option[0], function(res){
      console.log('LINES', res.split('\n'));
      var line = res.split('\n')[2];
      if (!line.match(/^Current\: /)) {
        doneSettingOpt();
      }
      var curValue = line.replace(/^Current\: /, '').trim();
      debug('optionsOnce', '[Currently] OPT:', option[0], ', VAL:', curValue);
      if (''+option[1] === curValue) {
        debug('optionsOnce', 'Already set to target value, skipping...');
        doneSettingOpt();
      } else {
        debug('optionsOnce', 'Setting to:', option[1]);
        oldSettings.push([option[0], curValue]);
        doneSettingOpt();
        // proc.gmd('--set-config ' + option[0] + '=' + (isNaN(option[1])?'"'+option[1]+'"':option[1]), function(res){
        //   debug('optionsOnce', '[Set] OPT:', option[0], ', TO:', option[1], ' (old:', curValue,')');
        //   doneSettingOpt();
        // });
      }
    });
  }, function finishedOptions(){
    debug('optionsOnce', 'Old settings:', oldSettings);
    _this.oldSettings = oldSettings;
    _this.newSettings = opts;
    debug('optionsOnce', 'Done setting options');
    //_this.rollbackSettings();
    next(_this);
  });
  return this;
};

Camera.prototype.rollbackSettings = function(next) {
  if (typeof this.oldSettings === 'undefined') {
    if (next) {
      next();
    }
    return;
  }
  debug('rollbackSettings', 'Rolling back settings #', this.oldSettings.length);
  next();
  return;
  // 
  // REMOVED: Instead append old values after action
  // 
  // async.eachSeries(this.oldSettings, function(option, doneSettingOpt){
  //   debug('rollbackSettings', 'Rolling back:', option);
  //   proc.gmd('--set-config ' + option[0] + '=' + (isNaN(option[1])?'"'+option[1]+'"':option[1]), function(){
  //     debug('rollbackSettings', 'Rolled back:', option);
  //     doneSettingOpt();
  //   });
  // }, function(){
  //   if (next) {
  //     next();
  //   }
  // });

};

Camera.prototype.gpipe = function(cmd, next, env) {
  var option;
  if (this.newSettings && this.newSettings.length > 0) {
    for (var i = 0; i < this.newSettings.length; i++) {
      option = this.newSettings[i];
      cmd = '--set-config ' + option[0] + '=' + (isNaN(option[1])?'"'+option[1]+'"':option[1]) + ' ' + cmd;
    }
  }

  if (this.oldSettings && this.oldSettings.length > 0) {
    for (var x = 0; x < this.oldSettings.length; x++) {
      option = this.oldSettings[x];
      cmd += ' --set-config ' + option[0] + '=' + (isNaN(option[1])?'"'+option[1]+'"':option[1]);
    }
  }

  debug('gpipe cmd', cmd);
  return proc.gpipe(cmd, next, env);
};

/************************/
/* Camera Functionality */
/************************/


Camera.prototype.capture = function() { //Stream
  return this.gpipe('--capture-image-and-download --stdout');
  //var stream = this.gpipe('--capture-image-and-download --stdout');
  var _this = this;
  // stream.on('end', function(){
  //   debug('Rolling back settings...');
  //   _this.rollbackSettings(next);
  // });
  return stream;
};

Camera.prototype.capturex = function(next) {
  //proc.gmd('--set-config /main/imgsettings/imageformat=0')

  next(proc.gpipe('--capture-image-and-download --stdout'));
};


Camera.prototype.preview = function() {

  return proc.gpipe('--capture-image-and-download --stdout');
};






module.exports = Camera;
